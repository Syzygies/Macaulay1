incr-set prlevel 1
if #0=3 START
incr-set prlevel -1
;;; Usage:
;;; 	<curve_on_cubic points C I
;;;
;;; Given a 3x2 matrix "points" representing 2 points in P2
;;; (other than the coordinate points) and an ideal C in
;;; 3 variables (eg a curve in P2) this script sets I to the 
;;; ideal of the image scheme on the cubic IN THE CURRENT RING
;;; obtained by blowing up the 6 points given
;;; by "points" and the 4 coord points. To get the ideal of 
;;; the cubic itself, take I to be the zero ideal.
;;; 
;;; (The machine checks whether there are 4 such cubics, 
;;;  no quadrics, and no 3 colinear points. If the number 
;;; of cubics is not 4, the program halts.) 
;;; 
incr-set prlevel 1
jump END
;;; Parameters:
;;;      points = 3 x 2 matrix of numbers, the columns
;;;        representing the coordinates of the points. 
;;;        This matrix must be a matrix over the polynomial ring
;;;        in 3 variables.
;;;      C = ideal over the same ring in 3 variables.
;;;
;;; Output values:
;;;       I = the ideal obtained by intersecting the ideal C with
;;;         the subring generated by the 4 cubics.
;;;         I is written in the current
;;;         ring, which must have at least 4 variables.
;;;
;;; See the examples for a method of getting a curve in a given 
;;; divisor class.
;;;
;;; Caveats: The number of cubics must be 4.
;;;
; created 9/11/89 DE
START:
;get a handle to the current ring:
<ideal @curring 

;make the ideal of the points:
setring #1
iden 3 @I
<ideal @ones 1 1 1
transpose @ones @ones
concat @I @ones
concat @I #1

;Check whether 3 points lie on a line
wedge @I 3 @I3
compress @I3 @I3
ncols @I3 @dependencies
int @dependencies 20-@dependencies 
if (@dependencies)=0 continue
shout echo There are 
shout type @dependencies
shout echo linear dependencies among the chosen points.

continue:

<points @I @points
<res @points @points
;shout betti @points
k-basis @points.2 @J
3
3
mult @points.1 @J points

;Check whether there is a conic through the points:
k-basis @points.2 @J
2
2
mult @points.1 @J @conics
ncols @conics @nconics
if @nconics=0 continueA
shout echo There is a conic 
shout type @conics
shout echo containing the chosen points 

continueA:
k-basis @points.2 @J
3
3
mult @points.1 @J @cubics
ncols @cubics @ncubics
if (@ncubics)=4 continueB
shout echo There are  
shout type @ncubics
shout echo cubics
shout type @cubics
shout echo containing the chosen points, so I quit. 
jump cleanup

continueB:
setring @curring
<push_forward1 @cubics #2 #3

cleanup:
kill @curring @I @ones @I3 @dependencies 
kill @points @conics @nconics @J @cubics 
kill @ncubics  
END:
incr-set prlevel -1

$;;;;;;;; EXAMPLE SECTION ;;;;;;;;;;;;;;;;;;;;;;;;;
reset

<ring 3 a-z P2
<ring 4 a-z P3

setring P2

;Make the matrix of points:
<ideal p1 1 -1 2
<ideal p2 1 2 3
transpose p1 p1
transpose p2 p2
copy p1 p
concat p p2
type p

;a plane curve:
setring P2
<ideal C1 3a+4b+5c ;line not through any point
<ideal C2 a ;line through 2 points
<ideal C3 b+5a ;line through one of thepoints
<ideal zero 
setring P3

<curve_on_cubic p C1 I
nres I I
betti I
; total:      1     3     2 
; --------------------------
;     0:      1     -     - 
;     1:      -     3     2 
;twisted cubic

<curve_on_cubic p C2 I
nres I I
betti I
; total:      1     2     1 
; --------------------------
;     0:      1     2     1 
;line

<curve_on_cubic p C3 I
nres I I
betti I
; total:      1     2     1 
; --------------------------
;     0:      1     1     - 
;     1:      -     1     1 
;plane conic in P3.

<curve_on_cubic p zero cubic
type cubic
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;The cases of degenerate point sets:
<ring 3 a-z P2
<ring 4 a-z P3

setring P2

<ideal C1 3a+4b+5c 

;three points on a line:
<ideal p1 1 -1 0
<ideal p2 1 2 3
transpose p1 p1
transpose p2 p2
copy p1 p
concat p p2
type p

setring P3
<curve_on_cubic p C1 I
nres I I
betti I

;6 points on a conic xy+xz-2yz.  
;If x=1, such points are given by z = 1/(2-(1/y)):
<ring 3 a-z P2
<ring 4 a-z P3

setring P2

<ideal C1 3a+4b+5c 
<ideal p1 1 2 2/3
<ideal p2 1 3 3/5
transpose p1 p1
transpose p2 p2
copy p1 p
concat p p2
type p

setring P3
<curve_on_cubic p C1 I
nres I I
betti I
;A plane cubic in this case
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<ring 3 a-z P2
<ring 4 a-z P3
setring P2

;A curve in the class
;d L - d1 L1 - ... - d6 L6
;on the cubic surface.
;The result has 
;degree = 3d - \sum di
;genus = (d-1)(d-2)/2  - \sum di(di-1)/2
<ideal mults a a a2 a3 a4 a5 ;these are of degree d1 .. d6

;Make the matrix of points:
<ideal p1 1 -1 2
<ideal p2 1 2 3
transpose p1 p1
transpose p2 p2
copy p1 p
concat p p2

;The full matrix of points:
iden 3 points
<ideal ones 1 1 1
transpose ones ones
concat points ones
concat points p
;Now make the ideal of points with multiplicities:
<points points candidates mults

betti candidates
;use this to decide what degree d to take:
int d 8 ;This gives an elliptic octic.
;(this only matters, as far as the betti 
;numbers go, mod 3.)

res candidates candidates
k-basis candidates.2 cand
d
d
mult candidates.1 cand cand
type cand

<random_mat 1 1 cand C


setring P3

<curve_on_cubic p C I
nres I I
betti I
; total:      1     8    11     4 
; --------------------------------
;     0:      1     -     -     - 
;     1:      -     -     -     - 
;     2:      -     1     -     - 
;     3:      -     -     -     - 
;     4:      -     6     9     3 
;     5:      -     1     2     1 
hilb I.1
; codimension = 2
; degree      = 8
; genus       = 1
<analytic_spread I.1
;4  ;This took a long time.
