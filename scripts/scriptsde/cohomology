incr-set prlevel 1
if #0=4 START 
incr-set prlevel -1

;;; Usage:
;;; 	<cohomology i M j H
;;;
;;; Computes the cohomology module
;;; H = \sum_{n >= 0} H^i(M(n))
;;; of the module M , regarded as
;;; a coherent sheaf on projective space.
incr-set prlevel 1
jump END
;;;
;;; Parameters:
;;;		i>0 the index of the cohomology group
;;;		M a module
;;;		j>0 a sufficiently large integer (see below.)
;;; Output values:
;;;		H = module.
;;;
;;; 	H is computed as the truncation in degrees >=0
;;; of the module Ext^i(J, M), where J is the ideal
;;; generated by the jth powers of the variables in the
;;; base ring of M.  
;;; 	For the answer to be guaranteed correct, it is enough
;;; to have:  All the syzygy modules of M are generated
;;; in degrees <= j + numvars - 1.
;;;
;;; Caveats:
;;; 	Note that the answer returned is 
;;; TRUNCATED IN DEGREES >= 0 !  To get all of Ext^i(J, M)
;;; use <cohomology1 i M j H instead.  This is desirable, for
;;; example, when computing H^0, or the first nonzero H^i with
;;; i >= 0, but in general the low degree parts may not mean much.

;Created 4/16/89 by D.Eisenbud
START:

<cohomology1 #1 #2 #3 @H

;Now truncate H in degrees >= 0:
std @H @H
trunc @H #4 !
	0
modulo #4 @H #4

kill @H
END:
incr-set prlevel -1

$;;;;;;;; EXAMPLE SECTION ;;;;;;;;;;;;;;;;;;;;;;;;;
reset
<ring 4 a-z r

;construct a module which will represent O(-3) restricted
;to a line in P3
<ideal supp a b
setdegs supp
	3
	;

<cohomology
<cohomology 0 supp 1 h
type h
betti h


<cohomology 1 supp 2 h
type h
std h h
hilb h
;       2 t  0
;      -7 t  1
;       8 t  2
;      -2 t  3
;      -2 t  4
;       1 t  5

;       2 t  0
;       1 t  1

; codimension = 4
; degree      = 3

;Remark:  taking j=1 in this computation does not work --
;that is, the bound given in the comment above is sharp
;in this case.

; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Cohomology of str sheaves of curves (also non CM in P3)
